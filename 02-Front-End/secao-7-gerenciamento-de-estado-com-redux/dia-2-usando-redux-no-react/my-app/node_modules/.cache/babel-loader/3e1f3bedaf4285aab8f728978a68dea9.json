{"ast":null,"code":"var _jsxFileName = \"/home/natalia/TRYBE/trybe-exercicios/02-Front-End/secao-7-gerenciamento-de-estado-com-redux/dia-2-usando-redux-no-react/my-app/src/SecondComponent.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { newAction } from './actions'; // Import referente a `action creator` criada para disparar a ação para a store.\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass SecondComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      inputValue: ''\n    }; // Esse estado irá armazenar o valor do input\n  }\n\n  render() {\n    const {\n      myFirstDispatch\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        onChange: event => this.setState({\n          inputValue: event.target.value\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 17,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => this.props.myFirstDispatch(this.state.inputValue),\n        children: \" / Executar qualquer tarefa\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 9\n      }, this), \"// O bot\\xE3o est\\xE1 disparando o mapDispatch e enviando o valor para a store\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 7\n    }, this);\n  }\n\n} // utilizando `action`:\n// const mapDispatchToProps = (dispatch) => ({\n// myFirstDispatch: (state) => dispatch({ type: 'NEW_ACTION', state }),\n// });\n// No caso acima, vemos que o mapDispatchToProps é uma função que retorna um objeto, e sua key recebe uma callback.\n// Essa callback terá um parâmetro correspondente ao estado que será enviado para a store.\n// Nessa callback, chamamos a função `dispatch`, que receberá como argumento a `action`,\n// que é um objeto contendo o \"type\" e o parâmetro da callback, o \"state\", que será o novo valor do estado.\n// utilizando `action creator `:\n\n\nconst mapDispatchToProps = dispatch => ({\n  myFirstDispatch: state => dispatch(newAction(state))\n}); // Podemos utilizar o mapDispatchToProps de outra forma também! Lembra o arquivo que foi criado contendo a função \"newAction?\n// No exemplo acima, o dispatch está recebendo como argumento a \"newAction\", que também é chamada de `action creator`.\n// E é aí que está a vantagem de utilizar as `action creator`, pois elas também geram uma `action`.\n\n\nexport default connect(null, mapDispatchToProps)(SecondComponent);","map":{"version":3,"names":["React","connect","newAction","SecondComponent","Component","constructor","props","state","inputValue","render","myFirstDispatch","event","setState","target","value","mapDispatchToProps","dispatch"],"sources":["/home/natalia/TRYBE/trybe-exercicios/02-Front-End/secao-7-gerenciamento-de-estado-com-redux/dia-2-usando-redux-no-react/my-app/src/SecondComponent.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport { newAction } from './actions';\n// Import referente a `action creator` criada para disparar a ação para a store.\n\nclass SecondComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { inputValue: '' };\n    // Esse estado irá armazenar o valor do input\n  }\n\n  render() {\n    const { myFirstDispatch } = this.props\n    return (\n      <div>\n        <input\n          type=\"text\"\n          onChange={event => this.setState({ inputValue: event.target.value })}\n        />\n        <button onClick={() => this.props.myFirstDispatch(this.state.inputValue)}> /\n          Executar qualquer tarefa\n        </button>\n    // O botão está disparando o mapDispatch e enviando o valor para a store\n      </div>\n    );\n  }\n}\n\n// utilizando `action`:\n// const mapDispatchToProps = (dispatch) => ({\n  // myFirstDispatch: (state) => dispatch({ type: 'NEW_ACTION', state }),\n// });\n\n// No caso acima, vemos que o mapDispatchToProps é uma função que retorna um objeto, e sua key recebe uma callback.\n// Essa callback terá um parâmetro correspondente ao estado que será enviado para a store.\n// Nessa callback, chamamos a função `dispatch`, que receberá como argumento a `action`,\n// que é um objeto contendo o \"type\" e o parâmetro da callback, o \"state\", que será o novo valor do estado.\n\n\n// utilizando `action creator `:\n\nconst mapDispatchToProps = (dispatch) => ({\n  myFirstDispatch: (state) => dispatch(newAction(state)),\n});\n\n// Podemos utilizar o mapDispatchToProps de outra forma também! Lembra o arquivo que foi criado contendo a função \"newAction?\n// No exemplo acima, o dispatch está recebendo como argumento a \"newAction\", que também é chamada de `action creator`.\n// E é aí que está a vantagem de utilizar as `action creator`, pois elas também geram uma `action`.\n\nexport default connect(null, mapDispatchToProps)(SecondComponent);"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,SAAT,QAA0B,WAA1B,C,CACA;;;;AAEA,MAAMC,eAAN,SAA8BH,KAAK,CAACI,SAApC,CAA8C;EAC5CC,WAAW,CAACC,KAAD,EAAQ;IACjB,MAAMA,KAAN;IACA,KAAKC,KAAL,GAAa;MAAEC,UAAU,EAAE;IAAd,CAAb,CAFiB,CAGjB;EACD;;EAEDC,MAAM,GAAG;IACP,MAAM;MAAEC;IAAF,IAAsB,KAAKJ,KAAjC;IACA,oBACE;MAAA,wBACE;QACE,IAAI,EAAC,MADP;QAEE,QAAQ,EAAEK,KAAK,IAAI,KAAKC,QAAL,CAAc;UAAEJ,UAAU,EAAEG,KAAK,CAACE,MAAN,CAAaC;QAA3B,CAAd;MAFrB;QAAA;QAAA;QAAA;MAAA,QADF,eAKE;QAAQ,OAAO,EAAE,MAAM,KAAKR,KAAL,CAAWI,eAAX,CAA2B,KAAKH,KAAL,CAAWC,UAAtC,CAAvB;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QALF;IAAA;MAAA;MAAA;MAAA;IAAA,QADF;EAYD;;AArB2C,C,CAwB9C;AACA;AACE;AACF;AAEA;AACA;AACA;AACA;AAGA;;;AAEA,MAAMO,kBAAkB,GAAIC,QAAD,KAAe;EACxCN,eAAe,EAAGH,KAAD,IAAWS,QAAQ,CAACd,SAAS,CAACK,KAAD,CAAV;AADI,CAAf,CAA3B,C,CAIA;AACA;AACA;;;AAEA,eAAeN,OAAO,CAAC,IAAD,EAAOc,kBAAP,CAAP,CAAkCZ,eAAlC,CAAf"},"metadata":{},"sourceType":"module"}